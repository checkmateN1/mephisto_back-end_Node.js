const enumPoker = require('../enum');
const enumCommon = require('../enum');

const INVALID_FRAME = enumCommon.enumCommon.INVALID_FRAME;
const testRegions = [{'id': 1, 'Player0_name': 'iblj J et', 'Player1_name': 'Wacuum008', 'Player2_name': 'SoLucky', 'Player0_balance': '23,5 BB', 'Player1_balance': '23,5 BB', 'Player2_balance': '25,0 BB', 'Player0_isActive': {'value': 'a', 'prob': 1.0}, 'Player1_isActive': {'value': 'a', 'prob': 1.0}, 'Player2_isActive': {'value': 'n', 'prob': 1.0}, 'Player0_bet': '2.0 BD', 'Player1_bet': '1,0 BB', 'Player2_bet': '', 'Pot': 'Pot 3,0 BB', 'Player0_isDealer': {'value': 'n', 'prob': 1.0}, 'Player1_isDealer': {'value': 'n', 'prob': 1.0}, 'Player2_isDealer': {'value': 'a', 'prob': 1.0}, 'Card1_value': {'value': 'None', 'prob': 1.0}, 'Card2_value': {'value': 'None', 'prob': 1.0}, 'Card3_value': {'value': 'None', 'prob': 1.0}, 'Card4_value': {'value': 'None', 'prob': 1.0}, 'Card5_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_value': {'value': 'None', 'prob': 0.9956691265106201}, 'Player1_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole2_value': {'value': 'None', 'prob': 1.0}, 'Card1_suit': {'value': 'None', 'prob': 1.0}, 'Card2_suit': {'value': 'None', 'prob': 1.0}, 'Card3_suit': {'value': 'None', 'prob': 1.0}, 'Card4_suit': {'value': 'None', 'prob': 1.0}, 'Card5_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole2_suit': {'value': 'None', 'prob': 1.0}, 'betAmount': '', 'isRaise': {'value': 'False', 'prob': 1.0}, 'isBet': {'value': 'False', 'prob': 1.0}, 'isCall': {'value': 'False', 'prob': 1.0}, 'isCheck': {'value': 'False', 'prob': 1.0}, 'isFold': {'value': 'False', 'prob': 1.0}}, {'id': 0, 'Player0_name': '', 'Player1_name': 'babrain', 'Player2_name': '', 'Player0_balance': '23,0 BB', 'Player1_balance': '23,0 BB', 'Player2_balance': '25,0 BB', 'Player0_isActive': {'value': 'a', 'prob': 1.0}, 'Player1_isActive': {'value': 'a', 'prob': 1.0}, 'Player2_isActive': {'value': 'n', 'prob': 1.0}, 'Player0_bet': '', 'Player1_bet': 'v', 'Player2_bet': '', 'Pot': 'Pot- 4,0 BB', 'Player0_isDealer': {'value': 'n', 'prob': 1.0}, 'Player1_isDealer': {'value': 'n', 'prob': 1.0}, 'Player2_isDealer': {'value': 'a', 'prob': 1.0}, 'Card1_value': {'value': 'j', 'prob': 0.9999980926513672}, 'Card2_value': {'value': '2', 'prob': 1.0}, 'Card3_value': {'value': '3', 'prob': 0.9996916055679321}, 'Card4_value': {'value': 'None', 'prob': 1.0}, 'Card5_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_value': {'value': 'None', 'prob': 0.9999970197677612}, 'Player1_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole2_value': {'value': 'None', 'prob': 1.0}, 'Card1_suit': {'value': 'c', 'prob': 1.0}, 'Card2_suit': {'value': 's', 'prob': 0.9989612102508545}, 'Card3_suit': {'value': 'c', 'prob': 1.0}, 'Card4_suit': {'value': 'None', 'prob': 1.0}, 'Card5_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole2_suit': {'value': 'None', 'prob': 1.0}, 'betAmount': 'e', 'isRaise': {'value': 'False', 'prob': 1.0}, 'isBet': {'value': 'False', 'prob': 1.0}, 'isCall': {'value': 'False', 'prob': 1.0}, 'isCheck': {'value': 'False', 'prob': 1.0}, 'isFold': {'value': 'False', 'prob': 1.0}}, {'id': 3, 'Player0_name': 'Posts BB', 'Player1_name': 'Vacuum008', 'Player2_name': '4iigin 8', 'Player0_balance': '21,0 BB', 'Player1_balance': '29,0 BB', 'Player2_balance': '23,5 BB', 'Player0_isActive': {'value': 'a', 'prob': 1.0}, 'Player1_isActive': {'value': 'a', 'prob': 1.0}, 'Player2_isActive': {'value': 'a', 'prob': 1.0}, 'Player0_bet': '1,0 BB', 'Player1_bet': 'v', 'Player2_bet': '0,5 BB', 'Pot': 'Pot 1,5 BB', 'Player0_isDealer': {'value': 'n', 'prob': 1.0}, 'Player1_isDealer': {'value': 'a', 'prob': 1.0}, 'Player2_isDealer': {'value': 'n', 'prob': 1.0}, 'Card1_value': {'value': 'None', 'prob': 1.0}, 'Card2_value': {'value': 'None', 'prob': 1.0}, 'Card3_value': {'value': 'None', 'prob': 1.0}, 'Card4_value': {'value': 'None', 'prob': 1.0}, 'Card5_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_value': {'value': 'None', 'prob': 0.9891301393508911}, 'Player1_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_value': {'value': 'j', 'prob': 1.0}, 'Player2_hole2_value': {'value': 'a', 'prob': 1.0}, 'Card1_suit': {'value': 'None', 'prob': 1.0}, 'Card2_suit': {'value': 'None', 'prob': 1.0}, 'Card3_suit': {'value': 'None', 'prob': 1.0}, 'Card4_suit': {'value': 'None', 'prob': 1.0}, 'Card5_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_suit': {'value': 'd', 'prob': 1.0}, 'Player2_hole2_suit': {'value': 's', 'prob': 0.9995007514953613}, 'betAmount': 'j', 'isRaise': {'value': 'False', 'prob': 1.0}, 'isBet': {'value': 'False', 'prob': 1.0}, 'isCall': {'value': 'False', 'prob': 1.0}, 'isCheck': {'value': 'False', 'prob': 1.0}, 'isFold': {'value': 'False', 'prob': 1.0}}, {'id': 2, 'Player0_name': 'Fcld', 'Player1_name': 'gaeleto1_', 'Player2_name': 'So Lucky', 'Player0_balance': '24,0 BB', 'Player1_balance': '23,0 BB', 'Player2_balance': '24,5 BB', 'Player0_isActive': {'value': 'n', 'prob': 1.0}, 'Player1_isActive': {'value': 'n', 'prob': 1.0}, 'Player2_isActive': {'value': 'n', 'prob': 1.0}, 'Player0_bet': '', 'Player1_bet': '3,5 BB', 'Player2_bet': '', 'Pot': 'Pot3,5 BB', 'Player0_isDealer': {'value': 'n', 'prob': 1.0}, 'Player1_isDealer': {'value': 'a', 'prob': 1.0}, 'Player2_isDealer': {'value': 'n', 'prob': 1.0}, 'Card1_value': {'value': 'None', 'prob': 1.0}, 'Card2_value': {'value': 'None', 'prob': 1.0}, 'Card3_value': {'value': 'None', 'prob': 1.0}, 'Card4_value': {'value': 'None', 'prob': 1.0}, 'Card5_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player1_hole2_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_value': {'value': 'None', 'prob': 1.0}, 'Player2_hole2_value': {'value': 'None', 'prob': 1.0}, 'Card1_suit': {'value': 'None', 'prob': 1.0}, 'Card2_suit': {'value': 'None', 'prob': 1.0}, 'Card3_suit': {'value': 'None', 'prob': 1.0}, 'Card4_suit': {'value': 'None', 'prob': 1.0}, 'Card5_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player0_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player1_hole2_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole1_suit': {'value': 'None', 'prob': 1.0}, 'Player2_hole2_suit': {'value': 'None', 'prob': 1.0}, 'betAmount': '.', 'isRaise': {'value': 'False', 'prob': 1.0}, 'isBet': {'value': 'False', 'prob': 1.0}, 'isCall': {'value': 'False', 'prob': 1.0}, 'isCheck': {'value': 'False', 'prob': 1.0}, 'isFold': {'value': 'False', 'prob': 1.0}}];
const regPot = /(S|D|B|\d)+(?!\S){0,4}((\.|\,){0,3}\d{1,2}){0,1}/;
const regBalance = /(S|D|B|\d)+\s{0,1}\d{0,2}(\.|\,){0,3}\d{0,1}/;
const regBÐµt = /(S|D|B|\d)+(?!\S){0,4}((\.|\,){0,3}\d{1,2}){0,1}/;
const regAllin = /(all|((4|A)(1|L|I)(1|L|I)-))/i;

class Player {
    constructor(id, adaptation) {
        this.id = id;
        this.adaptation = adaptation;
    }
}

class PlayPlayer {
    constructor(nickname, recognitionPosition, curBalance, amount, isActive, isDealer, cards) {
        this.nickname = nickname;
        this.recognitionPosition = recognitionPosition;
        this.curBalance = curBalance;
        this.betAmount = amount;
        this.isActive = isActive;
        this.isDealer = isDealer;
        this.cards = cards;
    }
}

class PlayFrame {
    constructor(handNumber, pot, playPlayers, board, isButtons, heroRecPosition, testNumber) {
        this.handNumber = handNumber;
        this.pot = pot;
        this.playPlayers = playPlayers;
        this.board = board;         // []
        this.isButtons = isButtons;
        this.heroRecPosition = heroRecPosition;       // 2 for spin&go
        this.testNumber = testNumber;
    }
}

class Validator {
    constructor(playSetup) {
        this.handNumber = -1;
        this.prevHandNumber = -1;
        this.playSetup = playSetup;
        this.playersCount;
        this.heroChair;
        this.prevFrame = null;
    }

    createFrame(recFrame) {
        this.playersCount = enumPoker.enumPoker.gameTypesSettings[this.playSetup.gameTypesSettings || 'Spin&Go'].playersCount;
        this.heroChair = enumPoker.enumPoker.gameTypesSettings[this.playSetup.gameTypesSettings || 'Spin&Go'].heroChair;
        const dealers = Array(this.playersCount).fill().reduce((count, pl, i) => recFrame[`Player${i}_isDealer`].value === 'a' ? count + 1 : count, 0);

        if (enumPoker.enumPoker.cardsSuits.includes(recFrame[`Player${this.heroChair}_hole1_suit`].value)
            && enumPoker.enumPoker.cardsSuits.includes(recFrame[`Player${this.heroChair}_hole2_suit`].value)
            && enumPoker.enumPoker.cardsValues.includes(recFrame[`Player${this.heroChair}_hole1_value`].value)
            && enumPoker.enumPoker.cardsValues.includes(recFrame[`Player${this.heroChair}_hole2_value`].value)
            && dealers > 0) {
            // good frame

        } else {
            return INVALID_FRAME;
        }

        const isNewHand = this.checkNewHand(recFrame);
        if (this.playSetup.rejectHand && !isNewHand) {
            return INVALID_FRAME;
        }

        if (isNewHand && enumPoker.enumPoker.cardsSuits.includes(recFrame.Card1_suit.value)) {           // reject new hand with any board cards
            this.playSetup.rejectHand = true;
            return INVALID_FRAME;
        }

        const validFrame = this.validateFrame(recFrame, isNewHand);

        if (validFrame === INVALID_FRAME) {
            return INVALID_FRAME;
        } else {
            // ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ ÑÑÐµÐ¹Ð¼
            const playPlayers = [];

            Array(this.playersCount).fill().forEach((pl, i) => {
                const nickname = validFrame[`Player${i}_name`];
                const balance = validFrame[`Player${i}_balance`];
                const bet = validFrame[`Player${i}_bet`];
                const isActive = validFrame[`Player${i}_isActive`].value === 'a';
                const isDealer = validFrame[`Player${i}_isDealer`].value === 'a';
                const cards = {
                    hole1Value: validFrame[`Player${i}_hole1_value`].value,
                    hole2Value: validFrame[`Player${i}_hole2_value`].value,
                    hole1Suit: validFrame[`Player${i}_hole1_suit`].value,
                    hole2Suit: validFrame[`Player${i}_hole2_suit`].value,
                };
                playPlayers[i] = new PlayPlayer(nickname, i, balance, bet, isActive, isDealer, cards);
            });

            const newHandNumber = isNewHand ? this.getHandNumber() : this.playSetup.handNumber;
            const board = [];  // ÐµÑÐ»Ð¸ Ð½Ðµ ÑÐ°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð° Ð¼Ð°ÑÑÑ Ð¸Ð»Ð¸ Ð½Ð¾Ð¼Ð¸Ð½Ð°Ð» - Ð¿ÑÐ¸ÑÐ²Ð°Ð¸Ð²Ð°ÐµÐ¼ undefined ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ Ð¼Ð°ÑÑÐ¸Ð²Ð°(ÐºÐ°ÑÑÐµ)
                               // ÑÐ°Ðº Ð¶Ðµ ÑÐ´Ð°Ð»ÑÐµÐ¼ Ð²ÑÐµ undefined c Ð¿ÑÐ°Ð²Ð¾Ð³Ð¾ ÐºÐ¾Ð½ÑÐ°

            Array(5).fill().forEach((card, i) => {
                const isValid = enumPoker.enumPoker.cardsSuits.includes(validFrame[`Card${i+1}_suit`].value)
                    && enumPoker.enumPoker.cardsValues.includes(validFrame[`Card${i+1}_value`].value);

                board[i] = isValid ? {
                    value: validFrame[`Card${i+1}_value`].value,
                    suit: validFrame[`Card${i+1}_suit`].value,
                } : undefined;
            });

            let cutCount = 0;
            board.reduceRight((isFoundValid, card) => {
                if (!isFoundValid) {
                    if (card) {
                        return true;
                    } else {
                        cutCount++;
                    }
                }
                return isFoundValid;
            }, false);

            while (cutCount) {
                board.pop();
                cutCount--;
            }

            const isButtons = validFrame.isFold.value;
            const playFrame = new PlayFrame(newHandNumber, validFrame.Pot, playPlayers, board, isButtons, this.heroChair);
            console.log('playFrame');
            console.log(playFrame);

            return playFrame;
        }
    };

    validateFrame(recFrame, isNewHand) {
        const playerBalances = {};
        const playerBets = {};
        let unclearBalancesCount = 0;
        let unclearBetsCount = [];
        let dealersCount = 0;
        let activeCount = 0;

        Array(this.playersCount).fill().forEach((pl, i) => {
            if ((isNewHand && recFrame[`Player${i}_isActive`].value === 'a') ||
                (!isNewHand && this.playSetup.initPlayers[i] !== undefined && !this.playSetup.wasFoldBefore(i))) {

                const player_balance = `Player${i}_balance`;
                if (regAllin.test(recFrame[player_balance])) {
                    playerBalances[player_balance] = 0;
                } else {
                    const matchBalance = recFrame[player_balance].match(regBalance);
                    playerBalances[player_balance] = matchBalance ? +matchBalance[0]
                            .replace(/S/, 5)
                            .replace(/D/, 0)
                            .replace(/B/, 8)
                            .replace(/(\s{1,2})*(?=(\d{0,2}(?=(\.|\,))))/, '')
                            .replace(/(\.|\,|\s)+(?=(\d)){0,1}/, '.')
                        : null;
                }

                const player_bet = `Player${i}_bet`;
                const matchBet = recFrame[player_bet].match(regBÐµt);
                playerBets[player_bet] = matchBet ? +matchBet[0]
                        .replace(/S/, 5)
                        .replace(/D/, 0)
                        .replace(/B/, 8)
                        .replace(/(\.|\,)+(?=(\d)){0,1}/, '.')
                    : 0;

                if (!this.isNumber(parseFloat(playerBalances[player_balance]))) {
                    playerBalances[player_balance] = 10000;
                    unclearBalancesCount++;
                }
                if (!this.isNumber(parseFloat(playerBets[player_bet]))) {
                    playerBets[player_bet] = 0;
                    unclearBetsCount++;
                }
                if (recFrame[`Player${i}_isDealer`].value !== 'a') {
                    dealersCount++;
                }
                if (recFrame[`Player${i}_isActive`].value !== 'a') {
                    activeCount++;
                }
            }
        });

        const matchPot = recFrame.Pot.match(regPot);
        const pot = {
            Pot: matchPot ? +matchPot[0]
                    .replace(/S/, 5)
                    .replace(/D/, 0)
                    .replace(/B/, 8)
                    .replace(/(\.|\,)+(?=(\d)){0,1}/, '.')
                : 0,
        };

        const isPotNumber = this.isNumber(parseFloat(pot.Pot));
        if (isNewHand) {
            if (!unclearBalancesCount
                && !unclearBetsCount
                && isPotNumber
                && pot.Pot > 0
                && dealersCount === 1
                && activeCount > 1) {     // good first frame
                return Object.assign(recFrame, pot, playerBets, playerBalances);
            } else {
                return INVALID_FRAME;
            }
        } else {        // not new hand
            if (!isPotNumber) {
                pot.Pot = 0;
            }

            const isNewStreet = this.isStreetChanged(recFrame);
            const currentStreet = this.playSetup.rawActionList[this.playSetup.rawActionList.length - 1].street;
            if (isNewStreet === undefined) {
                console.log('Ð¿ÑÐ¾Ð¿ÑÑÐµÐ½Ð½Ð° Ð¾Ð´Ð½Ð° Ð¸Ð»Ð¸ Ð±Ð¾Ð»ÐµÐµ ÑÐ»Ð¸Ñ - Ð¾ÑÐ¼ÐµÐ½ÑÐµÐ¼ Ð¿Ð¾Ð¿ÑÑÐºÑ Ð²Ð°Ð»Ð¸Ð´Ð°ÑÐ¸Ð¸');
                this.playSetup.rejectHand = true;
                return INVALID_FRAME;
            }

            const isTerminalStreetState = this.playSetup.isTerminalStreetState();

            if (isTerminalStreetState && !isNewStreet) {
                console.log('ÑÐµÑÐ¼Ð¸Ð½Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¸ Ð½ÐµÑÑ ÑÐ»ÐµÐ´ÑÑÑÐµÐ¹ ÐºÐ°ÑÑÑ - Ð¶Ð´ÐµÐ¼ ÑÐ»ÐµÐ´ÑÑÑÑÑ ÑÐ»Ð¸ÑÑ');
                return INVALID_FRAME;
            }

            const balancesDiffArr = [];
            const bets = [];
            const balancesDiff = this.playSetup.initPlayers.reduce((balancesDiff, player, i) => {
                if (this.playSetup.initPlayers[i] !== undefined) {
                    if (this.playSetup.wasFoldBefore(i)) {         // compare last move balance with init balance
                        balancesDiffArr[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.getLastValidMoveBalance(i);
                        return balancesDiff + balancesDiffArr[i];
                    } else {
                        balancesDiffArr[i] = this.playSetup.initPlayers[i].initBalance - playerBalances[`Player${i}_balance`];
                        return balancesDiff + balancesDiffArr[i];
                    }
                } else {
                    return balancesDiff;
                }
            }, 0);

            if (pot.Pot === balancesDiff) {
                // Ð²Ð°Ð»Ð¸Ð´Ð¸ÑÑÐµÐ¼ Ð¸ Ð·Ð°Ð¼ÐµÐ½ÑÐµÐ¼ ÑÑÐ°Ð²ÐºÐ¸
                if (!isNewStreet) {
                    balancesDiffArr.forEach((balance, i) => {
                        if (balance !== undefined) {
                            if (this.playSetup.wasFoldBefore(i)) {
                                playerBets[`Player${i}_bet`] = this.playSetup.getLastValidMoveAmount(i);
                            } else {
                                playerBets[`Player${i}_bet`] = this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) - playerBalances[`Player${i}_balance`];
                            }
                        }
                    });
                } else if (!isTerminalStreetState) {
                    const currentMaxAmount = this.playSetup.maxAmountAtCurrentStreet();
                    const possibleMaxAmounts = [currentMaxAmount];
                    const possiblePlayers = [];
                    let validAmount;
                    this.playSetup.initPlayers.forEach((player, i) => {
                        if (player !== undefined) {
                            if (!this.playSetup.wasFoldBefore(i)) {
                                const initBalance = this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition);
                                possiblePlayers.push({ i, initBalance });

                                const  amount = initBalance - playerBalances[`Player${i}_balance`] + playerBets[`Player${player.i}_bet`];
                                if (possibleMaxAmounts.includes(amount)) {
                                    validAmount = amount;
                                }
                            }
                        }
                    });

                    const isFoundValidBets = possibleMaxAmounts.reduce((isAlreadyFound, amount) => {
                        if (!isAlreadyFound) {
                            return possiblePlayers.reduce((isAlreadyFound, player) => {
                                if (!isAlreadyFound) {
                                    if ((player.initBalance - playerBalances[`Player${player.i}_balance`]  === playerBets[`Player${player.i}_bet`] + amount)
                                    && (playerBalances[`Player${player.i}_balance`] > 0 || playerBets[`Player${player.i}_bet`] > 0)) {
                                        // found right amount at previous street. Setting players bets
                                        balancesDiffArr.forEach((balance, i) => {
                                            if (balance !== undefined) {
                                                if (this.playSetup.wasFoldBefore(i)) {
                                                    playerBets[`Player${i}_bet`] = this.playSetup.getLastValidMoveStreet(i) === currentStreet ? this.playSetup.getLastValidMoveAmount(i) : 0;
                                                } else {
                                                    playerBets[`Player${i}_bet`] = Math.max(player.initBalance - playerBalances[`Player${player.i}_balance`] - amount, 0);
                                                }
                                            }
                                        });
                                        return true;
                                    } else {
                                        return false;
                                    }
                                } else {
                                    return true;
                                }
                            }, false);
                        } else {
                            return true;
                        }
                    }, false);

                    if (!isFoundValidBets) {
                        console.log('all bets are with mistake! But its ok with balances and pot. Invalid frame!');
                        return INVALID_FRAME;
                    }
                } else {        // new street and terminal state
                    const maxAmount = this.playSetup.maxAmountAtCurrentStreet();
                    this.playSetup.initPlayers.forEach((player, i) => {
                        if (player !== undefined) {
                            if (this.playSetup.wasFoldBefore(i)) {
                                playerBets[`Player${i}_bet`] = this.playSetup.getLastValidMoveAmount(i);
                            } else {
                                playerBets[`Player${i}_bet`] = Math.max(this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) - playerBalances[`Player${i}_balance`] - maxAmount, 0);
                            }
                        }
                    });
                }
            } else {        // pot or balances are wrong
                if (!isNewStreet) {
                    const balancesDiffArrBets = [];
                    const balancesDiffByBets = this.playSetup.initPlayers.reduce((balancesDiff, player, i) => {
                        if (this.playSetup.initPlayers[i] !== undefined) {
                            if (this.playSetup.wasFoldBefore(i)) {         // compare last move balance with init balance
                                balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.getLastValidMoveBalance(i);
                                return balancesDiff + balancesDiffArrBets[i];
                            } else {
                                balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) + playerBets[`Player${i}_bet`];
                                return balancesDiff + balancesDiffArrBets[i];
                            }
                        } else {
                            return balancesDiff;
                        }
                    }, 0);

                    if (pot.Pot === balancesDiffByBets) {     // pot and bets are correct
                        this.playSetup.initPlayers.forEach((player, i) => {
                            if (player !== undefined) {
                                playerBalances[`Player${i}_balance`] = this.playSetup.initPlayers[i].initBalance - balancesDiffArrBets[i];
                            }
                        });
                    } else if (balancesDiff === balancesDiffByBets) {       // balances and bets are correct
                        pot.Pot = balancesDiff;
                    } else {
                        console.log('2 or more mistakes in bets, balances or pot. Invalid frame');
                        return INVALID_FRAME;
                    }
                } else {        // new street and wrong pot or balances
                    if (!isTerminalStreetState) {
                        // Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÐ¼ ÑÑÐ¾ ÑÑÐ°Ð²ÐºÐ¸ Ð¸ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð²ÐµÑÐ½Ñ
                        // ÐµÑÐ»Ð¸ Ð¾Ð½Ð¸ Ð²ÐµÑÐ½Ñ, ÑÐ¾ Ð¿ÑÐ¸ÑÐ¾ÑÑ Ð±Ð°Ð»Ð°Ð½ÑÐ¾Ð² Ñ Ð½Ð°ÑÐ°Ð»Ð° ÑÐ»Ð¸ÑÑ Ð±ÑÐ´ÐµÑ ÑÐ°Ð²ÐµÐ½ ÑÑÐ°Ð²ÐºÐ°Ð¼ + ÑÐ¾Ð²Ð¿Ð°Ð²ÑÐ¸Ð¼Ð¸ Ð°Ð¼Ð°ÑÐ½ÑÐ°Ð¼Ð¸
                        // Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÑÑÐ°Ð²ÐºÐ¸ Ð¸ Ð´Ð¾Ð»Ð¶Ð½Ñ ÑÐ¾Ð²Ð¿Ð°ÑÑÑ ÐºÐ°Ðº Ð¼Ð¸Ð½Ð¸Ð¼ÑÐ¼ 2 Ð¿Ð¾ÑÐµÑÐ¸ Ð±Ð°Ð»Ð°Ð½ÑÐ° = ÑÑÐ¾ Ð¸ ÐµÑÑÑ Ð¼Ð°ÐºÑÐÐ¼Ð°ÑÐ½Ñ!! (ÐµÑÐµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐµ ÐºÑÐ¾ Ð² Ð¾Ð»ÑÐ½Ðµ)
                        // ÑÑÐ°Ð²ÐºÐ¸ Ð¸ Ð±Ð°Ð»Ð°Ð½ÑÑ Ñ ÑÑÐ¸Ñ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² Ð²ÐµÑÐ½Ñ

                        // ÐµÑÐ»Ð¸ Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð»Ð¸ 2 Ð¸ Ð±Ð¾Ð»ÐµÐµ Ð¼Ð°ÐºÑÐÐ¼Ð°ÑÐ½ÑÐ¾Ð² - Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÐ¼, ÑÑÐ¾ Ð²ÐµÑÐ½Ñ Ð¿Ð¾Ñ Ð¸ ÑÑÐ°Ð²ÐºÐ¸
                        // Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ ÑÑÐ°Ð²ÐºÐ¸ Ð¸ ÑÐ¼ÐµÐ½ÑÑÐ°ÐµÐ¼ Ð¿Ð¾Ñ Ð´Ð¾ ÑÐµÑÐ¼Ð¸Ð½Ð°Ð»ÑÐ½Ð¾Ð³Ð¾, Ð¿ÑÑÐ°ÐµÐ¼ÑÑ Ð²ÑÑÐ¸ÑÐ»Ð¸ÑÑ ÐºÑÐ¾ Ð¸Ð· Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð²Ð»Ð¾Ð¶Ð¸Ð» Ð² Ð¿Ð¾Ñ Ð½Ð° ÑÐ»Ð¸ÑÐµ
                        // Ð¸ Ð¸ÑÐµÐ¼ Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶ÐµÐ½Ð¸Ñ ÑÑÐ¾Ð¼Ñ Ð² ÑÐ¾Ð²Ð¿Ð°Ð²ÑÐ¸Ñ Ð±Ð°Ð»Ð°Ð½ÑÐµ + ÑÑÐ°Ð²ÐºÐµ Ñ Ð°Ð¼Ð°ÑÑÐ¾Ð¼ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð½ÑÐ¼ Ð¸Ð· Ð¿ÑÐ¸ÑÐ¾ÑÑÐ° Ð¿Ð¾ÑÐ° Ð½Ð° ÑÐ»Ð¸ÑÐµ
                        const currentMaxAmount = this.playSetup.maxAmountAtCurrentStreet();
                        const possibleMaxAmounts = {};
                        let maxAmount;
                        this.playSetup.initPlayers.reduce((isFound, player, i) => {
                            if (!isFound && player !== undefined) {
                                if (!this.playSetup.wasFoldBefore(i)
                                || this.playSetup.getLastValidMoveStreet(i) === currentStreet) {
                                    const initBalance = this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition);
                                    const amount = initBalance - playerBalances[`Player${i}_balance`] - playerBets[`Player${i}_bet`];
                                    if (!(amount in possibleMaxAmounts)) {
                                        possibleMaxAmounts[amount] = initBalance - amount > 0;
                                    } else {
                                        if (!possibleMaxAmounts[amount] || initBalance - amount > 0) {
                                            maxAmount = amount; // bingo!
                                            return true;
                                        }
                                    }
                                }
                            }
                            return isFound;
                        }, false);

                        if (maxAmount !== undefined) {
                            // Ð·Ð½Ð°ÐµÐ¼ Ð¼Ð°ÐºÑ Ð°Ð¼Ð°ÑÐ½Ñ Ð¸ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¿ÑÐ¾Ð²ÐµÑÐ¸ÑÑ Ð¿Ð¾Ñ Ð¸Ð»Ð¸ Ð²ÑÐµ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð¿Ð¾ ÑÑÐ°Ð²ÐºÐ°Ð¼ + Ð°Ð¼Ð°ÑÐ½Ñ, Ð° Ð·Ð°ÑÐµÐ¼ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð²ÑÐµÐ¼ Ð²Ð°Ð»Ð¸Ð´Ð½ÑÐµ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð¸Ð»Ð¸ Ð¿Ð¾Ñ
                            // Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÐµÐ¼ ÐºÑÐ¾ ÑÑÐ¾Ð»Ð´Ð¸Ð» Ð¼ÐµÐ¶Ð´Ñ ÑÑÐµÐ¹Ð¼Ð°Ð¼Ð¸ Ð¸ Ð²ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð´Ð»Ñ Ð½ÐµÐ³Ð¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÐµ Ð¼ÐµÑÑÐ° ÑÐ¾Ð»Ð´Ð°
                            const foldChair = this.getFoldedChair(recFrame);

                            if (foldChair !== undefined) {  // found one folded player
                                // create an arr with possible maxAmounts
                                const maxBalancesDiffWhenFolded = [];
                                const foldedPlayerBetAtNewStreet = playerBets[`Player${foldChair}_bet`];
                                if (!foldedPlayerBetAtNewStreet && this.playSetup.getLastValidMoveAmount(foldChair) < currentMaxAmount) {
                                    maxBalancesDiffWhenFolded.push(currentMaxAmount);
                                }
                                if (!foldedPlayerBetAtNewStreet && maxAmount > currentMaxAmount) {
                                    maxBalancesDiffWhenFolded.push(maxAmount);
                                }

                                // ÑÐ¾ÑÐ¼Ð¸ÑÑÐµÐ¼ Ð¸ ÑÐ¾ÑÑÐ¸ÑÑÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð² ÑÐ¾ ÑÑÐ°Ð²ÐºÐ°Ð¼Ð¸
                                this.playSetup.initPlayers.forEach((player, i) => {
                                    if (player !== undefined) {
                                        if (!this.playSetup.wasFoldBefore(i) && i !== foldChair) {  // folded between frames
                                            if (playerBets[`Player${i}_bet`] > foldedPlayerBetAtNewStreet) {
                                                maxBalancesDiffWhenFolded.push(playerBets[`Player${i}_bet`] + maxAmount);
                                            }
                                        }
                                    }
                                });

                                let validBalanceDiffForFoldedPlayer;
                                const balancesDiffArrBets = [];
                                maxBalancesDiffWhenFolded.reduce((isFound, foldedBalanceDiff) => {
                                    if (!isFound) {
                                        const balancesDiffByBets = this.playSetup.initPlayers.reduce((balancesDiff, player, i) => {
                                            if (this.playSetup.initPlayers[i] !== undefined) {
                                                if (this.playSetup.wasFoldBefore(i)) {         // compare last move balance with init balance
                                                    balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.getLastValidMoveBalance(i);
                                                    return balancesDiff + balancesDiffArrBets[i];
                                                } else if (i === foldChair) {

                                                    balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) + foldedBalanceDiff;
                                                    return balancesDiff + balancesDiffArrBets[i];
                                                } else {
                                                    balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) + maxAmount + playerBets[`Player${i}_bet`];
                                                    return balancesDiff + balancesDiffArrBets[i];
                                                }
                                            } else {
                                                return balancesDiff;
                                            }
                                        }, 0);

                                        if (balancesDiffByBets === pot.Pot) {   // found call sizing for  + pot and bets are valid!
                                            validBalanceDiffForFoldedPlayer = foldedBalanceDiff;
                                            return true;
                                        }
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }, false);

                                if (validBalanceDiffForFoldedPlayer !== undefined) {
                                    // Ð±ÐµÑÑ Ð¸ Ð¿Ð¾Ñ Ð²Ð°Ð»Ð¸Ð´Ð½ÑÐµ, Ð° ÑÐ°Ðº Ð¶Ðµ Ð¼Ð°ÐºÑÐÐ¼Ð°ÑÐ½Ñ Ð¸ ÑÐ°Ð·Ð¼ÐµÑ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹ ÑÐ¾Ð³Ð¾ ÐºÑÐ¾ ÑÑÐ¾Ð»Ð´Ð¸Ð»
                                    this.playSetup.initPlayers.forEach((player, i) => {
                                        if (player !== undefined) {
                                            playerBalances[`Player${i}_balance`] = this.playSetup.initPlayers[i].initBalance - balancesDiffArrBets[i];
                                        }
                                    });
                                } else {
                                    console.log(`Ð±ÑÐ» Ð½Ð°Ð¹Ð´ÐµÐ½ Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð¾Ð¶Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ Ð¼Ð°ÐºÑÐÐ¼Ð°ÑÐ½Ñ Ð½Ð° Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐ¹ ÑÐ»Ð¸ÑÐµ: ${maxAmount}, Ð½Ð¾ Ð»Ð¸Ð±Ð¾ Ð¿Ð¾Ñ Ð»Ð¸Ð±Ð¾ ÑÑÐ°Ð²ÐºÐ¸ Ð½Ðµ Ð²ÐµÑÐ½Ñ`);
                                    return INVALID_FRAME;
                                }
                            } else {
                                // no one folded between frames and we have maxAmount
                                const balancesDiffArrBets = [];
                                const balancesDiffByBets = this.playSetup.initPlayers.reduce((balancesDiff, player, i) => {
                                    if (this.playSetup.initPlayers[i] !== undefined) {
                                        if (this.playSetup.wasFoldBefore(i)) {         // compare last move balance with init balance
                                            balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.getLastValidMoveBalance(i);
                                            return balancesDiff + balancesDiffArrBets[i];
                                        } else {
                                            balancesDiffArrBets[i] = this.playSetup.initPlayers[i].initBalance - this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) + maxAmount + playerBets[`Player${i}_bet`];
                                            return balancesDiff + balancesDiffArrBets[i];
                                        }
                                    } else {
                                        return balancesDiff;
                                    }
                                }, 0);

                                if (balancesDiffByBets === pot.Pot) {
                                    // Ð·Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð²ÑÐµ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑ ÑÑÐ°Ð²ÐºÐ¸ Ð¸ balancesDiffArrBets;
                                    this.playSetup.initPlayers.forEach((player, i) => {
                                        if (this.playSetup.initPlayers[i] !== undefined) {
                                            playerBalances[`Player${i}_balance`] = this.playSetup.initPlayers[i].initBalance - balancesDiffArrBets[i];
                                        }
                                    });
                                } else if (balancesDiffByBets === balancesDiff) {
                                    pot.Pot = balancesDiff;
                                } else {
                                    console.log(`Ð±ÑÐ» Ð½Ð°Ð¹Ð´ÐµÐ½ Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð¾Ð¶Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ Ð¼Ð°ÐºÑÐÐ¼Ð°ÑÐ½Ñ Ð½Ð° Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐ¹ ÑÐ»Ð¸ÑÐµ: ${maxAmount}, Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ 2 Ð¸Ð»Ð¸ Ð±Ð¾Ð»ÐµÐµ ÑÐ¸ÑÑÑ Ð½Ðµ Ð²ÐµÑÐ½Ñ`);
                                    return INVALID_FRAME;
                                }
                            }

                        } else {
                            // Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð½Ðµ Ð²ÐµÑÐ½Ñ, Ð½Ð¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð²ÐµÑÐ½Ñ ÑÑÐ°Ð²ÐºÐ¸ - Ð¿ÑÑÐ°ÐµÐ¼ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ Ð°Ð¼Ð°ÑÐ½Ñ Ð¸Ð· Ð¿ÑÐ¸ÑÐ¾ÑÑÐ° Ð¿Ð¾ÑÐ° Ð·Ð° ÑÐ»Ð¸ÑÑ
                            // const amountAVG = this.playSetup.initPlayers.reduce((pot, player, i) => {
                            //     return pot - (this.playSetup.initPlayers[i] === undefined || this.playSetup.wasFoldBefore(i)) ? 0 : playerBets[`Player${i}_bet`];
                            // }, pot.Pot) - this.playSetup.getPotStartStreet();  // potDiff at last street
                            //
                            // // 2) Ð½Ðµ Ð·Ð°Ð±ÑÐ²Ð°ÐµÐ¼ Ð¿ÑÐ¾ Ð¾Ð»ÑÐ½ÐµÑÐ¾Ð² ÐºÐ¾ÑÐ¾ÑÐºÐ¸Ñ
                            // // 3) Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð²Ð»Ð¾Ð¶Ð¸Ð»Ð¸ ÑÐµ, ÐºÑÐ¾ ÑÐ¶Ðµ ÑÑÐ¾Ð»Ð´Ð¸Ð» Ð½Ð° ÑÑÐ¾Ð¹ ÑÐ»Ð¸ÑÐµ
                            //
                            // const notActivePlayers = [];
                            // const playerAmounts = [];       // !! amounts for all players
                            // const amountAvgActive = this.playSetup.initPlayers.reduce((pot, player, i) => {
                            //     if (this.playSetup.initPlayers[i] !== undefined) {
                            //         if (this.playSetup.wasFoldBefore(i)) {
                            //             const balDiff = this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) - this.playSetup.getLastValidMoveBalance(i);
                            //             notActivePlayers.push(i);
                            //             playerAmounts[i] = balDiff;
                            //             return pot - balDiff;
                            //         } else {
                            //             const endBalance = this.playSetup.getLastValidMoveBalance(i);
                            //             const balDiff = this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition) - endBalance;
                            //             if (balDiff && endBalance === 0) {      // player went to allin at current street
                            //                 notActivePlayers.push(i);
                            //                 playerAmounts[i] = balDiff;
                            //                 return pot - balDiff;
                            //             }
                            //         }
                            //     }
                            //     return pot;
                            // }, amountAVG);
                            //
                            //
                            // const foldChair = this.getFoldedChair(recFrame);
                            // let foldAmount;
                            // if (foldChair !== undefined) {  // somebody folded between frames
                            //     // 1) Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÑÐ¾ ÑÐ¾Ð»Ð´ÑÐ½ Ð½Ðµ ÐºÐ¾Ð»Ð¸Ð» Ð¼Ð°ÐºÑ Ð°Ð¼Ð°ÑÐ½Ñ
                            //     const foldOnCurrMaxAmountAmount = this.playSetup.getPrevAmountOnCurStreet(foldChair);
                            //
                            //     // Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÐ¼, ÑÑÐ¾ Ð¾Ð½ ÑÑÐ¾Ð»Ð´Ð¸Ð» Ð½Ð° Ð¼Ð°ÐºÑ Ð°Ð¼Ð°ÑÐ½Ñ Ð¸ Ð±Ð¾Ð»ÑÑÐµ Ð½Ð¸ÐºÑÐ¾ Ð½Ðµ Ð¿Ð¾Ð²ÑÑÐ°Ð»
                            //     notActivePlayers.push(foldChair);
                            //     foldAmount = foldOnCurrMaxAmountAmount < currentMaxAmount ? foldOnCurrMaxAmountAmount : currentMaxAmount;
                            //     playerAmounts[foldChair] = foldAmount;
                            // }
                            //
                            // const amountAvgActiveWithoutFolder = amountAvgActive - foldAmount || 0;
                            //
                            // const activePlayers = [];
                            // const initBalances = [];
                            // this.playSetup.initPlayers.forEach((player, i) => {
                            //     if (player !== undefined && !notActivePlayers.includes(i)) {
                            //         const initBalance = this.playSetup.initPlayerBalance(this.playSetup.initPlayers[i].enumPosition);
                            //         initBalances.push(initBalance);
                            //         activePlayers[i] = initBalance;
                            //     }
                            // });
                            //
                            // const activePlayersTMP = activePlayers.slice();
                            //
                            // initBalances.sort((a, b) => a - b);
                            // const sortedActivePlayers = initBalances.map(balance => {
                            //     const playerIndex = activePlayersTMP.indexOf(balance);
                            //     activePlayersTMP[playerIndex] = undefined;
                            //     return { playerIndex, balance };
                            // });
                            //
                            // const amountsActivePlayers = [];
                            // sortedActivePlayers.reduce((playersRestCount, player) => {
                            //     const terminalAmount = (amountAvgActiveWithoutFolder - amountsActivePlayers.reduce((sum, cur) => sum + cur, 0))/playersRestCount;
                            //     amountsActivePlayers.push(Math.min(terminalAmount, player.balance));
                            //     return playersRestCount - 1;
                            // }, sortedActivePlayers.length);
                            //
                            // // Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÐµÑÑÑ Ð»Ð¸ Ð² amountsActivePlayers Ð¼Ð¸Ð½Ð¸Ð¼ÑÐ¼ 2 ÑÐ°Ð¼ÑÑ Ð±Ð¾Ð»ÑÑÐ¸Ñ Ð¼Ð°ÐºÑ Ð°Ð¼Ð°ÑÐ½ÑÐ°
                            // let maxValidAmount;
                            // amountsActivePlayers.sort((a, b) => a - b);
                            // if (amountsActivePlayers.length > 2
                            //     && amountsActivePlayers[amountsActivePlayers.length - 1] === amountsActivePlayers[amountsActivePlayers.length - 2]) {
                            //     // Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÑÐ¾ ÑÐ¾ÑÑ Ð±Ñ Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¸Ð³ÑÐ¾ÐºÐ° ÑÐ¾Ð²Ð¿Ð°Ð» Ð¿ÑÐ¸ÑÐ¾ÑÑ Ð°Ð¼Ð°ÑÐ½Ñ + ÑÑÐ°Ð²ÐºÐ° Ñ Ð¿ÑÐ¸ÑÐ¾ÑÑÐ¾Ð¼ ÐµÐ³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÐ° Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ Ð½Ð°ÑÐ°Ð»Ð° Ð¿ÑÐµÐ´ ÑÐ»Ð¸ÑÑ
                            //
                            // }

                        }

                    } else {    // new street + terminal state and and wrong pot or balances
                        // Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÐµÑ Ð»Ð¸ Ð¿Ð¾Ñ - Ð²ÑÐµ ÑÑÐ°Ð²ÐºÐ¸ Ñ ÑÐµÑÐ¼Ð¸Ð½Ð°Ð»ÑÐ½ÑÐ¼ Ð¿Ð¾ÑÐ¾Ð¼.

                        const potByBets = this.playSetup.initPlayers.reduce((pot, player, i) => {
                            if (player !== undefined) {
                                return pot - this.playSetup.wasFoldBefore(i) ? 0 : playerBets[`Player${i}_bet`];
                            }
                            return pot;
                        }, pot.Pot);

                        const curRawPot = this.playSetup.getPot();

                        if (curRawPot === potByBets) {    // Ð²ÐµÑÐ½ÑÐ¹ Ð¿Ð¾Ñ Ð¸ ÑÑÐ°Ð²ÐºÐ¸
                            this.playSetup.initPlayers.forEach((player, i) => {
                                if (player !== undefined) {
                                    if (this.playSetup.wasFoldBefore(i)) {
                                        playerBalances[`Player${i}_balance`] = this.playSetup.getLastValidMoveBalance(i);
                                    } else {
                                        playerBalances[`Player${i}_balance`] = this.playSetup.getLastValidMoveBalance(i) - playerBets[`Player${i}_bet`];
                                    }
                                }
                            });
                        } else {    // Ð±ÐµÑÑ Ð¸Ð»Ð¸ Ð¿Ð¾Ñ Ð½Ðµ Ð²ÐµÑÐ½Ñ
                            // Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð¿ÑÐ°Ð²Ð¸Ð»ÑÐ½Ð¾ÑÑÑ Ð±Ð°Ð»Ð°Ð½ÑÐ¾Ð² Ñ Ð±ÐµÑÐ°Ð¼Ð¸
                            const potByBetsRawPot = this.playSetup.initPlayers.reduce((pot, player, i) => {
                                if (player !== undefined) {
                                    return pot + this.playSetup.wasFoldBefore(i) ? 0 : playerBets[`Player${i}_bet`];
                                }
                                return pot;
                            }, curRawPot);
                            if (balancesDiff === potByBetsRawPot) {     // Ð²ÐµÑÐ½Ñ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð¸ ÑÑÐ°Ð²ÐºÐ¸
                                pot.Pot = balancesDiff;
                            } else {
                                console.log(`ÑÐµÑÐ¼Ð¸Ð½Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ. ÐÐ¾Ñ Ð¸ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð»Ð¸, Ð¿Ð¾Ñ Ð¸ ÑÑÐ°Ð²ÐºÐ¸ Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð»Ð¸, Ð±ÐµÑÑ Ð¸ Ð±Ð°Ð»Ð°Ð½ÑÑ Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð»Ð¸`);
                                return INVALID_FRAME;
                            }
                        }
                    }
                }
            }
        }
        return Object.assign(recFrame, pot, playerBets, playerBalances);
    }

    getFoldedChair(recFrame) {
        let foldChair;
        this.playSetup.initPlayers.reduce((isFound, player, i) => {
            if (!isFound) {
                if (player !== undefined) {
                    if (!this.playSetup.wasFoldBefore(i) && recFrame[`Player${i}_isActive`].value === 'n') {  // folded between frames
                        foldChair = i;
                        return true;
                    }
                }
            }
            return isFound;
        }, false);
        return foldChair;
    }

    isStreetChanged(recFrame) {
        if (this.playSetup.board.length === 0) {
            if (enumPoker.cardsSuits.includes(recFrame.Card3_suit.value)        // flop appeared
                && enumPoker.cardsSuits.includes(recFrame.Card3_value.value)
                && enumPoker.cardsSuits.includes(recFrame.Card2_suit.value)
                && enumPoker.cardsSuits.includes(recFrame.Card2_value.value)
                && enumPoker.cardsSuits.includes(recFrame.Card1_suit.value)
                && enumPoker.cardsSuits.includes(recFrame.Card1_value.value)) {
                if (!enumPoker.cardsSuits.includes(recFrame.Card4_suit.value)
                    && !enumPoker.cardsSuits.includes(recFrame.Card4_value.value)) {    // but not turn+
                    return true;
                } else {
                    return undefined;
                }
            } else {        // not all flop cards appeared or the is steel preflop
                return false;
            }
        } else if (this.playSetup.board.length === 3) {
            if (enumPoker.cardsSuits.includes(recFrame.Card4_suit.value)
                && enumPoker.cardsSuits.includes(recFrame.Card4_value.value)) {    // turn appeared
                if (!enumPoker.cardsSuits.includes(recFrame.Card5_suit.value)
                    && !enumPoker.cardsSuits.includes(recFrame.Card5_value.value)) {    // but not river
                    return true;
                } else {
                    return undefined;
                }
            }
        } else if (this.playSetup.board.length === 4) {
            if (enumPoker.cardsSuits.includes(recFrame.Card5_suit.value)
                && enumPoker.cardsSuits.includes(recFrame.Card5_value.value)) {    // river appeared
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    };

    getHandNumber() {
        const newHandNumber = Math.floor(Math.random()*1000000000000000000000000);
        return newHandNumber !== this.playSetup.handNumber ? newHandNumber : this.getHandNumber();
    }

    checkNewHand(recFrame) {
        if (this.prevFrame === null) {
            return true;
        }

        // board
        const sumBoardCardsDiff = Array(5).fill().reduce((sum, card, i) => {
            return sum + ((this.prevFrame[`Card${i+1}_suit`].value !== 'None'
                || this.prevFrame[`Card${i+1}_value`].value !== 'None')
                && recFrame[`Card${i+1}_suit`].value === 'None') ? 1 : 0;
        }, 0);

        // dealer
        const isDealerMoved = Array(this.playersCount).fill().reduce((count, pl, i) => {
            return count + recFrame[`Player${i}_isDealer`].value !== this.prevFrame[`Player${i}_isDealer`].value ? 1 : 0;
        }, 0) === 2; // 2 - one disappeared and another one appeared

        // hero
        const isHeroCardsChanged = recFrame[`Player${this.heroChair}_hole1_suit`].value !== this.prevFrame[`Player${this.heroChair}_hole1_suit`].value  // one and more cards have changed
            || recFrame[`Player${this.heroChair}_hole1_value`].value !== this.prevFrame[`Player${this.heroChair}_hole1_value`].value
            || recFrame[`Player${this.heroChair}_hole2_suit`].value !== this.prevFrame[`Player${this.heroChair}_hole2_suit`].value
            || recFrame[`Player${this.heroChair}_hole2_value`].value !== this.prevFrame[`Player${this.heroChair}_hole2_value`].value;

        return sumBoardCardsDiff > 1 || (isHeroCardsChanged && isDealerMoved);
    }

    isNumber(value) {
        return typeof +value === 'number' && !isNaN(value);
    }
}

const validatorCreator = (playSetup) => new Validator(playSetup);

const testFrameCreator = new Validator(testRegions[0]);



module.exports.validatorCreator = validatorCreator;







